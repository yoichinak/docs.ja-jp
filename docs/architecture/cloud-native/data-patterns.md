---
title: クラウドネイティブ データ パターン
description: Azure 向けのクラウドネイティブ .NET アプリの設計 |クラウドネイティブデータパターン
ms.date: 06/30/2019
ms.openlocfilehash: 0d251f3046fcd3f3a2f5d856a123a35d3f7ecff2
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/30/2019
ms.locfileid: "73841823"
---
# <a name="cloud-native-data-patterns"></a>クラウドネイティブ データ パターン

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

一元化されたデータは、パフォーマンス、スケーラビリティ、およびコストの削減につながる可能性がありますが、多くの課題があります。 マイクロサービス間でのデータのクエリは複雑です。 マイクロサービスにまたがるトランザクションは、クラウドネイティブアプリケーションではサポートされていない分散トランザクションとしてプログラムで管理する必要があります。 *一貫性*のある世界から*最終的な整合性*に移行します。

ここでは、これらの課題について説明します。

## <a name="cross-service-queries"></a>クロスサービスクエリ

アプリケーションが多数の独立したマイクロサービスに分散しているデータを照会する方法

図5-4 はこのシナリオを示しています。

![マイクロサービス間でのクエリ](./media/cross-service-query.png)

**図 5-4** マイクロサービス間でのクエリ

前の図では、ユーザーのショッピングカートに項目を追加する買い物かごマイクロサービスがあることに注意してください。 買い物かごのデータストアには、バスケットと lineItem テーブルが含まれていますが、製品と価格のマイクロサービスで見つかった製品や価格のデータは含まれていません。 項目を追加するには、買い物かごマイクロサービスに製品データと価格データが必要です。 製品と価格データを取得するためのオプションは何ですか?

図5-5 は、製品カタログと価格マイクロサービスの両方に対して直接 HTTP 呼び出しを行う買い物かごマイクロサービスを示しています。

![直接 http 通信](./media/direct-http-communication.png)

**図 5-5** 直接 HTTP 通信

を実装することは可能ですが、第4章では、マイクロサービス間での HTTP 呼び出しがシステムに対してどのように行われるかを説明しましたが、この方法は推奨されません。

図5-6 に示すアグリゲーターマイクロサービスを実装できます。

![アグリゲーターマイクロサービス](./media/aggregator-microservice.png)

**図 5-6** アグリゲーターマイクロサービス

この方法では、個々のマイクロサービスでビジネス操作ワークフローがカプセル化されますが、複雑さが増し、引き続き直接 HTTP 呼び出しが発生します。

クロスサービスクエリを実行するための一般的な方法では、図5-7 に示すように、具体化された[ビューパターン](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)を使用します。

![具体化ビューパターン](./media/materialized-view-pattern.png)

**Figure5-7**。 具体化ビューパターン

このパターンでは、(*読み取りモデル*と呼ばれる) ローカルテーブルを買い物かごサービスに直接配置します。このテーブルには、製品および料金マイクロサービスに必要なデータの非正規化されたコピーが含まれています。 このデータをショッピングバスケットマイクロサービス内に配置することで、高価なクロスサービス呼び出しを呼び出す必要がなくなります。 データをサービスに対してローカルにすると、応答時間と信頼性が向上します。

このアプローチを使用すると、システム内に重複するデータが存在することになります。 クラウドネイティブシステムでは、重複データは[アンチパターン](https://en.wikipedia.org/wiki/Anti-pattern)とは見なされず、クラウドネイティブシステムに実装されるのが一般的です。 ただし、1つのシステムだけが任意のデータセットの所有者になることができます。また、基になるデータの変更が発生するたびに、関連するすべての読み取りモデルを更新するために、レコードのシステム用の同期メカニズムを実装する必要があります。

## <a name="transactional-support"></a>トランザクションのサポート

マイクロサービス間でのクエリは困難ですが、マイクロサービス間でのトランザクションの実装は複雑になる可能性があります。 異なるマイクロサービスに存在するデータソース間でデータの一貫性を維持するための固有の課題を袖口することはできません。 図5-8 は、この問題を示しています。

![Saga パターンでのトランザクション](./media/saga-transaction-operation.png)

**図 5-8**. マイクロサービス間でのトランザクションの実装

前の図では、すべての独立したマイクロサービスが分散*作成注文*トランザクションに参加していることに注意してください。 ただし、5つの各マイクロサービスのトランザクションが成功する必要があります。それ以外の場合は、すべてのマイクロサービスが操作を中止してロールバックする必要があります。 組み込みのトランザクションサポートは各マイクロサービス内で利用できますが、5つのサービスすべてにまたがる分散トランザクションはサポートされていません。

この操作では、各マイクロサービスでデータの一貫性を維持するためにトランザクションサポートが不可欠であるため、プログラムを使用して分散トランザクションを構築する必要があります。

トランザクションサポートをプログラムで追加するための一般的なパターンは、 [Saga パターン](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/)です。 ローカルトランザクションをグループ化し、それぞれを順番に呼び出すことによって実装されます。 ローカルトランザクションが失敗した場合、Saga は操作を中止し、[補正トランザクション](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)のセットを呼び出して、前のローカルトランザクションによって行われた変更を元に戻します。 図5-9 は、Saga パターンを使用した失敗したトランザクションを示しています。

![Saga パターンでのロールバック](./media/saga-rollback-operation.png)

**図 5-9** トランザクションのロールバック

前の図では、 *GenerateContent*操作が music マイクロサービスで失敗したことに注意してください。 Saga は、補正トランザクション (赤) を呼び出して、コンテンツを削除し、支払いを取り消し、注文をキャンセルし、各マイクロサービスのデータを一貫性のある状態に戻します。

Saga パターンは、通常、関連する一連のイベントとして、または関連する一連のコマンドとして調整されます。

## <a name="cqrs-pattern"></a>CQRS パターン

CQRS ([コマンドクエリ責務分離](https://docs.microsoft.com/azure/architecture/patterns/cqrs)) は、データを書き込むデータを読み取る操作を分離するアーキテクチャパターンです。 このパターンは、パフォーマンス、スケーラビリティ、およびセキュリティを最大化するのに役立ちます。

通常のデータアクセスのシナリオでは、データの読み取りと書き込み操作の*両方*を実行する単一のモデル (エンティティとリポジトリオブジェクト) を実装します。

ただし、より高度なデータアクセスのシナリオでは、読み取りと書き込みのために個別のモデルとデータテーブルを利用すると便利な場合があります。 パフォーマンスを向上させるために、*クエリ*と呼ばれる読み取り操作は、負荷の高いテーブル結合を避けるために、データの非常に非正規化された表現に対してクエリを実行することがあります。 *書き込み*操作 (*コマンド*) は、完全に正規化されたデータの表現に対して更新される可能性があります。 次に、両方の表現を同期させておくためのメカニズムを実装する必要があります。通常、書き込みテーブルが変更されるたびに、データ変更を読み取りテーブルにレプリケートするイベントが発生します。

図5-10 は、CQRS パターンの実装を示しています。

![CQRS の実装](./media/cqrs-implementation.png)

**図 5-10** CQRS の実装

前の図では、コマンドモデルとクエリモデルが個別に実装されていることに注意してください。 さらに、各データ書き込み操作は書き込みストアに保存され、読み取りストアに反映されます。 最終的な[整合性](https://www.cloudcomputingpatterns.org/eventual_consistency/)の原則に基づいて伝達プロセスがどのように動作するかに注意してください。一方、読み取りモデルは最終的に書き込みモデルと同期しますが、プロセスに多少のずれが生じる可能性があります。

分離を実装することで、読み取りと書き込みを個別にスケーリングすることができます。 また、読み取りに関しては、書き込み操作に対してセキュリティを強化することもできます。

通常、CQRS パターンは、特定のニーズに基づいて、システムの限られたセクションに適用されます。

## <a name="relational-vs-nosql"></a>リレーショナル vs NoSQL

[NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/)テクノロジの影響は、特に分散クラウドネイティブシステムでは数多くできません。 この領域に新しいデータテクノロジが急増すると、リレーショナルデータベースに排他的に依存するソリューションが中断されました。

一方で、リレーショナルデータベースは数十年にわたり、一般的なテクノロジでした。 成熟し、実証済みで、広く実装されています。 競合するデータベース製品、専門知識、ツール abounds。 リレーショナルデータベースは、関連するデータテーブルのストアを提供します。 これらのテーブルには固定スキーマがあり、SQL (構造化照会言語) を使用してデータを管理し、 [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (原子性、一貫性、分離性、持続性とも呼ばれます) を保証します。

一方、SQL データベースは、高パフォーマンスの非リレーショナルデータストアを参照します。 これらは、使いやすさ、スケーラビリティ、回復性、および可用性の特性を excel で実現しています。 NoSQL は、正規化されたデータのテーブルを結合するのではなく、通常は JSON ドキュメントに自己記述型 (schemaless) データを格納します。 [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/)保証は提供されません。

これらの種類のデータベースの違いを理解する方法は、 [CAP 定理](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e)にあります。これは、状態を格納する分散システムに適用できる一連の原則です。 図5-11 は、キャップ定理の3つのプロパティを示しています。

![キャップ定理](./media/cap-theorem.png)

**図 5-11** CAP 定理

定理は、すべての分散データシステムが整合性、可用性、およびパーティションの許容範囲の間にトレードオフを提供し、どのデータベースでも次の3つのプロパティのうち2つのみを保証できることを示しています。

- *整合性*: クラスター内のすべてのノードは、すべてのレプリカが正しく更新されるまで要求をブロックする必要がある場合でも、最新のデータを使用して応答します。

- *可用性*: すべてのノードは、応答が最新のデータではない場合でも、適切な時間内に応答を返します。

- *パーティションの許容範囲*: ノードで障害が発生した場合、または別のノードとの接続が失われた場合に、システムが引き続き動作することを保証します。

リレーショナルデータベースは、整合性と可用性を備えていますが、パーティションの許容範囲ではありません。 リレーショナルデータベース (シャーディングなど) のパーティション分割は困難であり、パフォーマンスに影響を与える可能性があります。

一方、NoSQL データベースでは、通常、パーティションの許容範囲 (水平方向のスケーラビリティと高可用性) が示されます。 CAP 定理によって指定されているように、3つの原則はどちらも2つしかないため、整合性プロパティは失われます。

NoSQL データベースは分散され、一般に汎用サーバー間でスケールアウトされます。 そうすることで、地理的なリージョン内とリージョン間の両方で、コストを削減して優れた可用性を実現できます。 これらのマシンまたはノード間でデータをパーティション分割してレプリケートし、冗長性とフォールトトレランスを提供できます。 欠点は、整合性です。 1つの NoSQL ノード上のデータに対する変更は、他のノードに反映されるまでに時間がかかることがあります。 通常、NoSQL データベースノードは、表示されているデータが古く、まだ更新されていない場合でも、クエリに直ちに応答します。

これは、ACID トランザクションがサポートされていない分散データシステムの特性である既知の[最終的な整合性](https://www.cloudcomputingpatterns.org/eventual_consistency/)です。 データ項目が更新されてから、その更新が各レプリカノードに反映されるまでにかかる時間が短くなります。 米国の NoSQL データベースの製品項目を更新しても、ヨーロッパのレプリカノードと同じデータ項目を同時に照会した場合は、ヨーロッパのノードが製品の変更で更新されるまで、以前の製品情報を取得することがあります。 トレードオフは、[強力な一貫性を確保](https://en.wikipedia.org/wiki/Strong_consistency)し、すべてのレプリカノードが更新されるのを待ってからクエリ結果を返すことによって、大規模なスケールとトラフィックのボリュームをサポートできますが、古いデータが表示される可能性があります。

NoSQL データベースは、次の4つのモデルで分類できます。

- *ドキュメントストア*(MongoDB、CouchDB、Couchbase): データ (および対応するメタデータ) は、データベース内の非正規化された JSON ベースのドキュメントで、非 relationally に格納されます。

- *キー/値ストア*(Redis、riak、memcached): データは、ユーザーデータの値にマップされた一意のアクセスキーに対して実行されるシステム操作と共に、単純なキーと値のペアに格納されます。

- *ワイド列ストア*(HBase、Cassandra): 関連データは、複数のテーブルを結合しなくても、通常は1つの単位として取得されるデータを使用して、1つの列に入れ子になったキーと値のペアのセットとして列形式で格納されます。

- *グラフストア*(neo4j、titan): データは、ノード間のリレーションシップを指定するエッジと共に、ノード内にグラフィカルな表現として格納されます。

NoSQL データベースは、特にデータが比較的単純な場合に、大規模なデータを処理するように最適化できます。 次の場合に NoSQL データベースを検討します。

- ワークロードには大規模な同時実行性が必要です。
- 多数のユーザーがいます。
- データは、リレーションシップなしでのみ表現できます。
- データを地理的に分散する必要があります。
- ACID の保証は必要ありません。
- は、汎用的ハードウェアにデプロイされます。

次に、次の場合にリレーショナルデータベースを検討します。

- ワークロードには、中規模から大規模のスケールが必要です。
- 同時実行は大きな問題ではありません。
- ACID 保証が必要です。
- データは relationally で表現することをお勧めします。
- アプリケーションは、大規模なハイエンドハードウェアにデプロイされます。

次に、Azure クラウドのデータストレージについて見ていきます。

>[!div class="step-by-step"]
>[前へ](distributed-data.md)
>[次へ](azure-data-storage.md)
