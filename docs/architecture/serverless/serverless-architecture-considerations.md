---
title: サーバーレスアーキテクチャに関する考慮事項-サーバーレスアプリ
description: 状態管理や永続ストレージから、スケーリング、ログ記録、トレース、診断まで、サーバーレスアプリケーションを設計する際の課題について理解します。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: c856683cf6910be98661e634246cd003b93a6d76
ms.sourcegitcommit: 4f4a32a5c16a75724920fa9627c59985c41e173c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/17/2019
ms.locfileid: "72522431"
---
# <a name="serverless-architecture-considerations"></a>サーバーレス アーキテクチャの考慮事項

サーバーレスアーキテクチャを採用することには、いくつかの課題が伴います。 このセクションでは、注意すべき一般的な考慮事項をいくつか紹介します。 これらの課題にはすべてソリューションがあります。 すべてのアーキテクチャの選択肢と同様に、サーバーレスにするかどうかの決定は、長所と短所を慎重に検討した後に行う必要があります。 アプリケーションのニーズによっては、サーバーレス実装が特定のコンポーネントに適したソリューションではないと判断する場合があります。

## <a name="managing-state"></a>状態の管理

一般にマイクロサービスと同様に、サーバーレス関数は既定でステートレスです。 状態を回避することで、サーバーレスを短期にすることができます。また、スケールアウトし、中央障害点なしで回復性を提供することができます。 状況によっては、ビジネスプロセスで状態が必要になる場合があります。 プロセスに状態が必要な場合は、2つのオプションがあります。 サーバーレス以外のモデルを採用することも、状態を提供する別のサービスと対話することもできます。 状態を追加すると、ソリューションが複雑になり、スケーリングが難しくなり、単一障害点が生じる可能性があります。 関数が完全に状態を要求するかどうかを慎重に検討してください。 答えが「はい」の場合は、サーバーレスで実装するのが理にかなっているかどうかを判断します。

サーバーレスの利点を損なうことなく、状態を採用するためのいくつかのソリューションがあります。 一般的なソリューションには、次のようなものがあります。

- Redis などの一時的なデータストアまたは分散キャッシュを使用する
- SQL や CosmosDB などのデータベースに状態を格納する
- 持続性のある関数のようなワークフローエンジンを使用して状態を処理する

最後の行は、サーバーレスで実装することを検討しているプロセス内で、状態管理が必要であることを認識する必要があるということです。

## <a name="long-running-processes"></a>実行時間の長いプロセス

サーバーレスの多くの利点は、一時的なプロセスに依存しています。 短い実行時間を使用すると、サーバーレスプロバイダーは、関数の終了時にリソースを解放し、ホスト間で関数を共有することが容易になります。 ほとんどのクラウドプロバイダーでは、関数が実行できる合計時間が約10分に制限されています。 プロセスにかかる時間が長くなる場合は、別の実装を検討してください。

いくつかの例外と解決策があります。 1つの解決策として、プロセスを小さなコンポーネントに分割して、個々の実行に要する時間を短縮することができます。 依存関係が原因でプロセスが長時間実行されている場合は、持続性のある関数などのソリューションを使用して非同期ワークフローを検討することもできます。 持続性のある関数は、外部プロセスが終了するのを待機している間に、プロセスの状態を一時停止および維持します。 非同期処理により、実際のプロセスの実行時間が短縮されます。

## <a name="startup-time"></a>起動時間

サーバーレス実装で考えられる問題の1つは、起動時間です。 リソースを節約するために、多くのサーバーレスプロバイダーは "オンデマンド" でインフラストラクチャを作成します。 サーバーレス関数が一定の時間が経過するとトリガーされる場合、その関数をホストするためのリソースを作成または再起動する必要がある場合があります。 場合によっては、コールドスタートによって数秒の遅延が発生することがあります。 起動時間は、プロバイダーとサービスレベルによって異なります。 アプリの成功を最小限に抑えることが重要な場合は、スタートアップ時間に対処するためのいくつかの方法があります。

- 一部のプロバイダーでは、インフラストラクチャが常にオンになっていることを保証するサービスレベルに対して支払いを行うことができます。
- キープアライブ機構を実装します (エンドポイントに ping を実行して、"起動済み" のままにします)。
- コンテナー化された関数の手法で Kubernetes のようなオーケストレーションを使用します (ホストは既に実行されているため、新しいインスタンスが非常に高速になります)。

## <a name="database-updates-and-migrations"></a>データベースの更新と移行

サーバーレスコードの利点は、アプリケーション全体を再デプロイしなくても、新しい関数をリリースできることです。 この利点は、関係するリレーショナルデータベースがある場合に欠点になる可能性があります。 データベーススキーマに対する変更は、サーバーレスの更新と同期するのが困難です。 問題が発生し、変更をロールバックする必要がある場合は、さらに問題が発生します。 データの整合性は、マイクロサービスやサーバーレス機能のベストプラクティスとして、独自のデータを所有していることが挙げられます。 変更は、コンピューティングとデータの1つの単位としてデプロイすることができます。 現実には、多くのレガシシステムは、サーバーレスアーキテクチャで調整する必要がある大規模なバックエンドデータベースを特徴としています。

スキーマのバージョン管理を解決するための一般的な方法は、既存のプロパティや列を変更するのではなく、新しい情報を追加することです。 たとえば、todo リストのブール値 "completed" フラグから "完了日" に移動する変更を考えてみます。 古いフィールドを削除するのではなく、データベースの変更は次のようになります。

1. 新しい "完了日" フィールドを追加します。
1. "Completed" ブール値フィールドを、完了した日付が現在の日付より後であるかどうかを評価する計算関数に変換します。
1. 完了したブール値が true に設定されている場合に、完了日を現在の日付に設定するトリガーを追加します。

一連の変更によって、従来のコードが "そのまま" 実行されるようになり、新しいサーバーレス関数は新しいフィールドを利用できます。

サーバーレスアーキテクチャのデータの詳細については、「[分散データ管理の課題と解決策](../microservices/architect-microservice-container-applications/distributed-data-management.md)」を参照してください。

## <a name="scaling"></a>スケーリング

サーバーレスが "サーバーなし" を意味するという誤解がよくあります。 実際には、"少ないサーバー" です。 スケーリングに関しては、バッキングインフラストラクチャが重要であることを理解しておくことが重要です。 ほとんどのサーバーレスプラットフォームでは、イベント密度が増加したときにインフラストラクチャがどのように拡張されるかを処理するコントロールのセットが提供されます。 さまざまなオプションから選択できますが、その方法は関数によって異なる場合があります。 さらに、関数は通常、関連するホストで実行されるので、同じホスト上の関数のスケールオプションが同じになります。 そのため、スケール要件に基づいてホストされる関数を整理し、実行する必要があります。

多くの場合、ルールでは、さまざまなパラメーターに基づいて、スケールアップ (ホストリソースの増加) とスケールアウト (ホストインスタンスの数の増加) の方法を指定します。 スケールのトリガーには、スケジュール、要求レート、CPU 使用率、メモリ使用量などがあります。 多くの場合、パフォーマンスが高くなります。 コストが安く、消費量ベースのアプローチは、要求レートが突然増加した場合にはすぐにはスケールされないことがあります。 前払いの "保険コスト" を支払うことと、需要が急激に増加することによる応答速度の低下を保証するというトレードオフがあります。

## <a name="monitoring-tracing-and-logging"></a>監視、トレース、およびログ記録

多くの場合、DevOps は、デプロイされたアプリケーションを監視しています。 サーバーレス機能を監視するための戦略を用意することが重要です。 最大の課題は、多くの場合、ユーザーが同じ相互作用の一部として複数の関数を呼び出すときに、相関関係があることです。 ほとんどのサーバーレスプラットフォームでは、サードパーティ製ツールにインポートできるコンソールログを使用できます。 テレメトリの収集の自動化、関連付け Id の生成と追跡、および特定のアクションの監視を行い、詳細な洞察を提供するオプションもあります。 Azure には、監視と分析のための高度な[Application Insights プラットフォーム](https://docs.microsoft.com/azure/azure-functions/functions-monitoring)が用意されています。

## <a name="inter-service-dependencies"></a>サービス間の依存関係

サーバーレスアーキテクチャには、他の機能に依存する機能が含まれている場合があります。 実際、サーバーレスアーキテクチャでは、相互作用または分散トランザクションの一部として複数のサービスが相互に呼び出されることは珍しくありません。 強力な結合を避けるために、サービスは互いに直接参照しないことをお勧めします。 サービスのエンドポイントを変更する必要がある場合、直接参照によって主要なリファクタリングが行われる可能性があります。 推奨される解決方法は、要求の種類の適切なエンドポイントを提供する、レジストリなどのサービス検出メカニズムを提供することです。 もう1つの解決策は、サービス間の通信に関するキューやトピックなどのメッセージングサービスを利用することです。

## <a name="managing-failure-and-providing-resiliency"></a>障害の管理と回復性の提供

また、*サーキットブレーカーパターン*を考慮することも重要です。何らかの理由でサービスが引き続き失敗する場合は、そのサービスを繰り返し呼び出すことはお勧めできません。 代わりに、代替サービスが呼び出されるか、依存サービスの正常性が再確立されるまでメッセージが返されます。 サーバーレスアーキテクチャでは、サービス間の依存関係を解決および管理するための戦略を考慮する必要があります。

サーキットブレーカーパターンを継続するには、サービスがフォールトトレランスと回復性を備えている必要があります。 フォールトトレランスとは、予期しない例外が発生した場合や無効な状態が検出された場合でも、アプリケーションの実行を継続する能力を指します。 フォールトトレランスは、通常、コード自体の機能であり、例外を処理するためにどのように記述されているかを示します。 回復性とは、アプリが障害から回復する能力を指します。 回復性は多くの場合、サーバーレスプラットフォームによって管理されます。 既存のサーバーに障害が発生した場合、プラットフォームは新しいサーバーレス関数インスタンスを起動できる必要があります。 また、新しいインスタンスがすべて失敗したときに、新しいインスタンスのスピンアップを停止できるように、プラットフォームもインテリジェントである必要があります。

詳細については、「[サーキットブレーカーパターンの実装](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md)」を参照してください。

## <a name="versioning-and-greenblue-deployments"></a>バージョン管理と緑/青のデプロイ

サーバーレスの大きな利点は、アプリケーション全体を再デプロイしなくても、特定の機能をアップグレードできることです。 アップグレードを正常に実行するには、関数を呼び出すサービスが正しいバージョンのコードにルーティングされるように、関数をバージョン管理する必要があります。 新しいバージョンを展開するための戦略も重要です。 一般的なアプローチでは、"グリーン/blue デプロイメント" を使用します。 緑の配置は、現在の関数です。 新しい "blue" バージョンが運用環境に展開され、テストされます。 テストに合格すると、新しいバージョンが公開されるように、緑と青のバージョンがスワップされます。 問題が発生した場合は、スワップバックできます。 バージョン管理と緑/青のデプロイをサポートするには、バージョンの変更に対応し、サーバーレスプラットフォームを使用してデプロイを処理する関数を作成する必要があります。 考えられる方法の1つは、 [Azure サーバーレスプラットフォーム](azure-functions.md#proxies)の章で説明されているプロキシを使用することです。

>[!div class="step-by-step"]
>[前へ](serverless-architecture.md)
>[次へ](serverless-design-examples.md)
